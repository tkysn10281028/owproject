# 目次

- バックエンド
  - ディレクトリについて
  - 配置資材の作成ルール(具体例で)
  - 命名規則(随時追加予定)
  - 細かいルール
- フロントエンド
- 環境

## バックエンド

### ディレクトリについて

- src/main/java 以下の構造は以下を採用し、**サブディレクトリの作成は原則として行わない**こと。

```
  com.oysterworld.portfolio.owproject_backend/
  │
  ├── app
  │    ├── business
  │         ┗── 各機能のディレクトリ
  │    ├── controller
  │         ┗── 各機能のディレクトリ
  │    └── service
  │         ┗── 各機能のディレクトリ
  │
  ├── base
  │
  ├── common
  │
  ├── database
  │    ┗── mapper
  │
  ├── exception
  │
  ┗── security
```

### 配置資材の作成ルール(具体例で)

あなたは架空のブログサービスを作りたい。ブログを投稿して、その内容を参照できる。  
→ このサービスの業務ドメインとビジネスロジックは以下のようになる。

- 業務ドメイン

  - ID(ブログの内容を識別できる一意なハッシュ値)
  - タイトル
  - 内容
  - 内部用 ID(ソートなどを行うための連番 ID)

- ビジネスロジック

  - タイトルからブログを取得する
  - ID からブログを取得する
  - 全てのブログの一覧を取得する
  - ブログを投稿する

→ また、補助要件として以下を作る必要がある。

- バリデーション
  - タイトルが空欄、もしくはスペースのみだった場合は入力エラー
  - ID が空欄、もしくはスペースのみだった場合は入力エラー
  - 同じタイトルのブログがすでに投稿されていた場合は入力エラー
  - 同じ ID が重複して存在している場合は、サーバーエラー
- データ永続化
  - ブログを投稿したらデータベースに格納する。

→ 以上を踏まえて、このサービスは以下のような構成になる。

```
  ┗── app
       ├── business
            ┗── blog
                 ┣── Blog                        ・・・業務ドメイン
                 ┗── BlogBusinessLogic           ・・・ビジネスロジック
       ├── controller
            ┗── blog
                 ┗── BlogController              ・・・webAPI
       └── service
            ┗── blog
                 ┣── BlogService                 ・・・ビジネスロジックからの呼び出しとDB連携
                 ┗── BlogValidationService       ・・・バリデーション
```

#### ※補足事項

★ ディレクトリ・クラスの切り方について  
例：Blog 画面に新規で画面追加。ブログの投稿・検索は Blog 画面、全てのブログの表示は BlogManage 画面　といったように切り分けたい。

> どの構成も一長一短のため、規模によって使い分けるのが良い。

1. ある 1 つの機能につき 1 つのディレクトリ・1 つのクラス(小規模向け)
   - メリット
     - 一つの機能でディレクトリもクラスもまとまっており保守性・可読性が非常に良い。
   - デメリット
     - 画面とロジックと DB が全て密結合のため仕様追加した際に全てのクラスを作る必要があり、修正時も影響が全クラスに及ぶ。
     - 機能が細分化されやすくなるので要件が複雑だとディレクトリが爆発する。
     - ビジネスロジック・業務ドメインが画面依存になってしまうので MVC 設計としてはイマイチ（ビジネスロジックが Presentation 層・Database 層を使う関係性でないといけない）

```

Blog 画面　　　　　　　　　　　　　　　BlogManage 画面
　　｜　　　　　　　　　　　　　　　　　　　　　｜
Blog.Response　　　　　　　　　　　BlogManage.Response
　　｜　　　　　　　　　　　　　　　　　　　　　｜
BlogController　　　　　　　　　　BlogManageController
　　｜　　　　　　　　　　　　　　　　　　　　　｜
  Blog　　　　　　　　　　　　　　　　　　BlogManage
　　｜　　　　　　　　　　　　　　　　　　　　　｜
BlogBusinessLogic　　　　　　　　BlogManageBusinessLogic
　　｜　　　　　　　　　　　　　　　　　　　　　｜
BlogService　　　　　　　　　　　　　BlogManageService
　　｜　　　　　　　　　　　　　　　　　　　　　｜
Blog.Model　　　　　　　　　　　　　　BlogManage.Model

```

2. サービスクラスが複数の ビジネスロジック に機能を提供(大規模向け)
   - メリット
     - 保守性・可読性がそこそこよく、また適度に疎結合。
     - 他のシステム（データベース・外部 API）と連携するレイヤとそれ以外のレイヤを分けることで外部要因による障害の切り分けが容易。
   - デメリット
     - 1.と同様に要件が複雑だとディレクトリが爆発する。
     - ビジネスロジック・業務ドメインが画面依存になってしまうので MVC 設計としてはイマイチ（ビジネスロジックが Presentation 層・Database 層を使う関係性でないといけない）

```
Blog 画面                           BlogManage 画面
　　｜　　　　　　　　　　　　　　　　　　　　　　｜
Blog.Response　　　　　　　　　　　　　BlogManage.Response
　　｜　　　　　　　　　　　　　　　　　　　　　　｜
BlogController                    BlogManageController
　　｜　　　　　　　　　　　　　　　　　　　　　　｜
  Blog　　　　　　　　　　　　　　　　　　　BlogManage
　　｜　　　　　　　　　　　　　　　　　　　　　　｜
BlogBusinessLogic　　　　　　　　　　BlogManageBusinessLogic
　　　　　　　　↖︎                       ↗︎
　　　　　　　　　　　　BlogService
　　　　　　　　　　　　　　　｜
　　　　　　　　　　　　Blog.Model
```

3. ビジネスロジックが複数の画面に機能を提供(大規模向け)
   - メリット
     - フロントとバックの依存がなくなるので、画面改修が入っても画面・コントローラのみの改修で済み、ビジネスロジックへの影響がない
     - ビジネスロジックが他のレイヤを使う関係になるので、MVC の設計にマッチする
   - デメリット
     - 保守性・可読性が低い(どのビジネスロジックがどの画面に対応しているかわからなくなる。。)

```
Blog 画面                           BlogManage 画面
　　｜　　　　　　　　　　　　　　　　　　　　　　｜
Blog.Response　　　　　　　　　　　　　　Blog.Response
　　｜　　　　　　　　　　　　　　　　　　　　　　｜
BlogController                    BlogManageController
　　　　　　　　↖︎                       ↗︎
　　　　　　　　　　　BlogBusinessLogic
　　　　　　　　　　　　　　　｜
　　　　　　　　　　　　　  Blog
　　　　　　　　　　　　　　　｜
　　　　　　　　　　　　BlogService
　　　　　　　　　　　　　　　｜
　　　　　　　　　　　　Blog.Model
```

### 命名規則(随時追加予定)

- クラス名は名詞ベース、メソッド名は動詞ベース。
- 全て英語を使用する(日本語は禁止)。
- 以下記法を使用する。

```
  ・Java(メソッド)　　　　　　・・・キャメルケース(※例　 exampleMethod)
  ・Java(フィールド)　　　　　・・・キャメルケース(※例　 exampleField)
  ・Java(クラス)　　　　　　　・・・パスカルケース(※例　 ExampleClass)
  ・Java(パッケージ名)　　　　・・・ケバブケース(※例　 example-package)
  ・SQL(テーブル名)　　　　　 ・・・大文字スネークケース(※例　 EXAMPLE_TABLE)
  ・SQL(フィールド名)　　　　 ・・・小文字スネークケース(※例　 EXAMPLE_COLUMN)
  ・SQL(予約語)　　　　　　　 ・・・大文字(※例　 EXAMPLE_TABLE)
```

- CRUD は以下の命名規則を使用する。
  - C：regist/post
  - R：get/find
  - U：update
  - D：delete
- boolean/Boolean 型は以下の命名規則を使用する。
  - is(例：isActive)/has(例：hasPermission)/can(例：canLogin)
- 各クラスの命名
  - API：~~Controller
  - ビジネスロジック：~~BusinessLogic
  - サービス：~~Service
  - ORM マッパークラス：~~Mapper
  - テストクラス：~Test
  - 例外：~~Exception

### 細かいルール

★ 業務ドメインクラスについて

1. 業務ドメインクラス(上記の例では Blog)の他に各レイヤで対応するオブジェクトを作成すること。

- データベース操作用オブジェクト(Model)
- リクエスト用オブジェクト(Request)
- レスポンス用オブジェクト(Response)
  なお各レイヤのオブジェクトはファイルに分けずに業務ドメインのクラスにまとめて記述し、業務ドメインのクラスからのみ生成できるようにする。
  > 各レイヤを大量のオブジェクトで汚すことを防ぐ狙い。

★ Controller クラス・例外処理について

1. webAPI は以下の JSON 形式で返却すること。

```
{
    message:メッセージ
    data:処理結果の返却データ
}
```

2. また、発生した例外の種類に応じて以下のステータスコードを返却する。

```
  400:ユーザーの不正なリクエスト(バリデーションエラーなど)
  401:認証エラー
  403:認可エラー
  500:サーバー側のエラー(サーバーが悪いエラー)
```
